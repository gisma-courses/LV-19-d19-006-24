{
  "hash": "b3a15a00a54ee6baeaadedcac51ecf7a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Untitled\"\neditor: visual\n---\n\n\n## Excursus: Creating training areas with mapedit\n\n### Using color composites for better training results\n\nFor this exercise, we use `mapedit`, a small but powerful package that allows you to digitize and edit vector data in Rstudio or an external browser. In combination with `mapview`, any \\[color composite\\] (https://custom-scripts.sentinel-hub.com/custom-scripts/sentinel-2/composites/) can also be used as a basis for digitization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## ##\n# ---- 0 Projekt Setup ----\nrequire(\"pacman\")\n#remotes::install_github(\"zivankaraman/CDSE\")\n# packages installing if necessary and loading\npacman::p_load(mapview, mapedit, tmap, tmaptools, raster, terra, stars, gdalcubes, sf, dplyr,CDSE, downloader, tidyverse,RStoolbox,rprojroot, exactextractr, randomForest, ranger, e1071, caret, link2GI, rstac, OpenStreetMap,colorspace)\n\n#--- Switch to determine whether digitization is required. If set to FALSE, the\nroot_folder = find_rstudio_root_file()\n\nm1 = tm_shape(pred_stack_2019) + tm_rgb(r=4, g=3, b=2) +\n  tm_layout(legend.outside.position = \"right\",\n            legend.outside = T,\n            panel.label.height=0.6,\n            panel.label.size=0.6,\n            panel.labels = c(\"r=1, g=2, b=3\")) +\n  tm_grid()\n\nm2 = tm_shape(pred_stack_2019) + tm_rgb(r=8, g=4, b=3) +\n  tm_layout(legend.outside.position = \"right\",\n            legend.outside = T,\n            panel.label.height=0.6,\n            panel.label.size=0.6,\n            panel.labels = c(\"r=8, g=4, b=3\")) +\n  tm_grid()\ntmap::tmap_arrange(m1,m2)\n```\n:::\n\n\n![](images/rgb.png)\n\nThe planes can be switched using the plane control. In true-color composites, the visible spectral channels Red (B04), Green (B03), and Blue (B02) are mapped to the corresponding red, green, and blue color channels, respectively, producing an image of the surface that closely resembles the natural \"color\" as it would be seen by a human sitting on the spacecraft. False color images are often created using the spectral channels for near-infrared, red, and green. They are particularly useful for assessing vegetation because plants reflect near-infrared and green light while absorbing red light (red-edge effect). Dense vegetation appears a darker red. Cities and open ground appear gray or light brown, water appears blue or black.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## ##\n\n#---- Digitization of training data ----\n\nif (digitize) {\n# For the supervised classification, we need training areas. You can digitize them as shown below or alternatively use QGis, for example\n\n# clearcut\n\n# For the false color composite r = 8, g = 4, b = 3, maxpixels = 1693870)\n# maxpixels has significantly higher memory requirements, vegetation in red\n# below the true color composite\ntrain_area_2019 <- mapview::viewRGB(pred_stack_2019, r = 4, g = 3, b = 2, maxpixels = 1693870) %>% mapedit::editMap()\n# Adding the attributes class (text) and id/year (integer)\nclearcut_2019 <- train_area_2019$finished$geometry %>% st_sf() %>% mutate(class = \"clearcut\", id = 1,year=2019)\ntrain_area_2020 <- mapview::viewRGB(pred_stack_2020, r = 4, g = 3, b = 2,maxpixels = 1693870) %>% mapedit::editMap()\nclearcut_2020 <- train_area_2020$finished$geometry %>% st_sf() %>% mutate(class = \"clearcut\", id = 1,year=2020)\n\n# other: all areas not belonging to clear cutting as representative as possible\ntrain_area_2019 <- mapview::viewRGB(pred_stack_2019, r = 4, g = 3, b = 2) %>% mapedit::editMap()\nother_2019 <- train_area_2019$finished$geometry %>% st_sf() %>% mutate(class = \"other\", id = 2,year=2019)\ntrain_area_2020 <- mapview::viewRGB(pred_stack_2020, r = 4, g = 3, b = 2) %>% mapedit::editMap()\nother_2020 <- train_area_2020$finished$geometry %>% st_sf() %>% mutate(class = \"other\", id = 2,year=2020)\n\ntrain_areas_2019_2020 <- rbind(clearcut_2019,clearcut_2020, other_2019,other_2020) # Reproject to the raster file\ntrain_areas_2019 = sf::st_transform(train_areas_2019_2020,crs = sf::st_crs(pred_stack_2019))\nmapview(filter(train_areas_2019_2020,year==2019), zcol=\"class\")\n# save geometries\nst_write(train_areas_2019_2020,paste0(envrmt$path_data,\"train_areas_2019_2020.gpkg\"))\n\n# Extract the training data for the digitized areas\ntDF_2019 = exactextractr::exact_extract(pred_stack_2019, filter(train_areas_2019_2020,year==2019), force_df = TRUE,\ninclude_cell = TRUE,include_xy = TRUE,full_colnames = TRUE,include_cols = \"class\")\ntDF_2020 = exactextractr::exact_extract(pred_stack_2020, filter(train_areas_2019_2020,year==2020), force_df = TRUE,\ninclude_cell = TRUE,include_xy = TRUE,full_colnames = TRUE,include_cols = \"class\")\n\n# again, copy together into a file\ntDF_2019 = dplyr::bind_rows(tDF_2019)\ntDF_2019$year = 2019\ntDF_2020 = dplyr::bind_rows(tDF_2020)\ntDF_2020$year = 2020\n# Delete any rows that contain NA (no data) values\ntDF_2019 = tDF_2019[complete.cases(tDF_2019) ,]\ntDF_2020 = tDF_2020[complete.cases(tDF_2020) ,]\n\ntDF= rbind(tDF_2019,tDF_2020)\n\n# check the extracted data\nsummary(tDF)\n\n# Save as R internal data format\n# is stored in the repo and can therefore be loaded (line below)\nsaveRDS(tDF, paste0(envrmt$path_data,\"tDF.rds\"))\n\n\n\n} else {\ntDF = readRDS(paste0(envrmt$path_data,\"tDF.rds\"))\n}\n```\n:::\n\n\nThe result is a table with training data for 2019 and 2020. The data set contains all raster information for all bands covered by the polygons for the classes \"clearcut\" and \"other\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## ##\nhead(tDF)\n```\n:::\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}