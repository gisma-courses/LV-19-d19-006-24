{
  "hash": "d8d44b467ccee9796a2b0caf9b653e2f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pattern-based spatial analysis\"\nsubtitle: \"How to discover and to describe\"\nauthor: \"Chris Reudenbach\"\nexecute:\n  eval: false\n  echo: true\ntitle-slide-attributes:\n  data-background-image: slide1/preview-image-mof.png\n  #data-background-size: contain\n  data-background-opacity: \"0.5\"\nformat:\n  revealjs:\n    theme: [../_extensions/metropolis-theme/metropolis.scss]\n    toc: false\n    toc-depth: 2\n    chalkboard: true\n    slide-number: true\n    footer: <gisma 2024>\n    menu: true\nlightbox: true\nspotlight:\n      useAsPointer: true\n      size: 5\n---\n\n\n## Spatial Patterns\n\nIn recent years, the ideas of analyzing spatial patterns have been extended through an approach called **pattern-based spatial analysis** [(Long in in. 2010; Cardille in in. 2010; Cardille in in. 2012; Jasiewicz i in. 2013; Jasiewicz i in. 2015)]{.smallcaps}.\n\nThe fundamental idea is to divide a big area into a large number of smaller areas which we may call local landscapes patches.\n\n::: {.callout-important appearance=\"minimal\"}\nNote: The patch size is depending on spatial data resolution and scale of the landscape\n:::\n\n::::: columns\n::: {.column width=\"25%\"}\n![](/assets/ng_grid.png)\n:::\n\n::: {.column width=\"45%\"}\nThe idea is to represent each of this arbitrary areas using a statistical description of the spatial pattern - a **spatial signature**.\n:::\n:::::\n\nThis spatial signatures can be **compared** using a large number of existing **distance or dissimilarity measures** [(Lin 1991; Cha 2007)]{.smallcaps}, which enables spatial analyses such as searching, change detection, clustering, or segmentation.\n\n------------------------------------------------------------------------\n\n\n## Spatial Signatures\n\n\nMost landscape metrics are single numbers representing specific features of a local landscape.\n\nSpatial signatures, on the other hand, are multi-element representations of landscape composition and configuration.\n\n:::: [.columns]\n\n::: {.column width=\"45%\"}\n![](/assets/index-29-bis-1.png)\n:::\n\n::: {.column width=\"45%\"}\nThe basic signature is the co-occurrence matrix:\n![](/assets/cooc.png)\n:::\n::::\n\n---\n\n## Spatial signatures dimension reduction & normalisation\n\n::::: columns\n\n::: {.column width=\"45%\"}\n\n\n\n![](/assets/index-31-1.png)\n:::\n\n::: {.column width=\"45%\"}\n\n::: fragment\n\n![**Reduced co-occurrence vector (cove)**](/assets/cove1.png)\n:::\n\n::: fragment\n\n![**Normalized co-occurrence vector(cove)**](/assets/cove3.png)\n:::\n::: fragment\n\n![**Co-occurrence vector (cove)**](/assets/cove3.png)\n:::\n\n:::\n:::::\n\n\n---\n\n## Dissimilarity measures Example 1\n\nMeasuring the distance between two signatures in the form of normalised vectors allows the dissimilarity between spatial structures to be determined. The package [**motif**] (https://jakubnowosad.com/motif/) is designed to do this work.\n\n::::: columns\n\n::: {.column width=\"30%\"}\n\n\n\n![](/assets/index-35-1.png)\n![](/assets/di1.png)\n:::\n\n::: {.column width=\"25%\"}\n:::\n\n::: {.column width=\"30%\"}\n\n\n\n![](/assets/index-37-1.png)\n![](/assets/di2.png)\n\n\n\n\n:::\n:::::\n\n::: fragment\n\n![Jensen-Shannon distance between the above rasters: **0.0684**](/assets/jsd1.png){width=35% fig-align=\"center\"}\n\n\n:::\n\n---\n\n\n## Dissimilarity measures Example 2\n\nMeasuring the distance between two signatures in the form of normalized vectors allows determining dissimilarity between spatial structures.\n\n::::: columns\n\n::: {.column width=\"30%\"}\n\n\n\n![](/assets/index-40-1.png)\n![](/assets/di3.png)\n:::\n\n::: {.column width=\"25%\"}\n:::\n\n::: {.column width=\"30%\"}\n\n\n\n![](/assets/index-41-1.png)\n![](/assets/di4.png)\n\n\n\n\n:::\n:::::\n\n::: fragment\n\n![Jensen-Shannon distance between the above rasters: **0.444**](/assets/jsd2.png){width=35% fig-align=\"center\"}\n:::\n\n---\n\n## Pattern-based spatial analysis\n\nThe distance between spatial signatures provides a powerful possibility to identify (dis)similarities in several contexts.\n\n:::: {layout=\"[30,30,30]\" layout-valign=\"bottom\"}\n\n![finding similar spatial structures - **one to many** comparison](/assets/lsp_search4.png)\n\n![quantitative assessment of changes in spatial structures - **one to one** comparison](/assets/lsp_compare2.png)\n\n\n![clustering similar spatial structures - **many to many** comparison](/assets/lsp_cluster4.png)\n\n\n::::\n\n---\n\n## One to many\n\nFinding areas with similar topography to the Suwalski Landscape Park\n\n::::: {layout=\"[1,1]\" layout-valign=\"bottom\"}\n\n![Topography Indices](/assets/lsp_search2.png){width=\"85%\"}\n\n![JSD Index](/assets/lsp_search4.png){width=\"85%\"}\n:::::\n\n---\n\n## One to one\n\n\nThe left maps are showing that many areas in the Amazon have undergone significant land cover changes between 1992 and 2018. The challenge now is to determine which areas have changed the most. The right map shows these areas identified by high JSD values. \n\n::: {.callout-important appearance=\"minimal\"}\nNote that changes in both **category and spatial configuration** are measured.\n:::\n\n::::: {layout=\"[0.75,0.35]\" layout-valign=\"bottom\"}\n\n![Landuse Types](/assets/lsp_compare1.png){width=\"85%\"}\n\n![JSD Index](/assets/lsp_compare2.png){width=\"85%\"}\n:::::\n\n---\n\n## Many to many\n\nAreas in Africa with similar spatial structures for two themes have been identified - land cover and landforms.\n\n![](/assets/lsp_cluster_map.png)\n\n---\n\n## Many to many\n\n![](/assets/lsp_cluster6.png){fig-align=\"center\" width=75% }\n\nThe quality of each cluster can be assessed using metrics:\n\n- **Intra-cluster heterogeneity**: determines distances between all landscapes within a group\n- **Inter-cluster isolation**: determines distances between a given group and all others\n\n---\n\n## Examples\n\n### coma\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(motif)\nr9 = rast(\"../exdata/r9.tif\")\nr9_sign_coma = lsp_signature(r9, type = \"coma\")\nr9_sign_coma\nr9_sign_coma$signature\n```\n:::\n\n\n### cove\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr9_sign = lsp_signature(r9, type = \"cove\")\nr9_sign\nr9_sign$signature\n```\n:::\n\n\n### search\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlandcover = rast(system.file(\"raster/landcover2015s.tif\", package = \"motif\"))\necoregions = read_sf(system.file(\"vector/ecoregionss.gpkg\", package = \"motif\"))\necoregion1 = ecoregions[1, ]\nlandcover1 = crop(landcover, ecoregion1, mask = TRUE)\nplot(landcover)\nplot(landcover1)\n\nsearch_result = lsp_search(landcover1, landcover, \n                           type = \"cove\", dist_fun = \"jensen-shannon\", window = 25,\n                           output = \"sf\")\nplot(search_result[\"dist\"])\n```\n:::\n\n\n### min/max\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch_result$id[which.min(search_result$dist)]\nsearch_results_75 = lsp_extract(landcover, window = 25, id = 75)\nplot(search_results_75)\n\nsearch_result$id[which.max(search_result$dist)]\nsearch_results_215 = lsp_extract(landcover, window = 25, id = 215)\nplot(search_results_215)\n```\n:::\n\n\n\n\n---\n\n## Exercises\n\n1. Read the study area polygon from the `exdata/harz_borders.gpkg` file using the `read_sf()` function from the **sf** package.\n2. Read the land cover raster data for Europe from the file `exdata/lc_europe.tif` using the function `rast()` from the package **terra**. Visualise both datasets.\n2. Crop and mask the raster to the polygon boundaries. Visualise the results.\n2. Compute a spatial signature for the study area. Can you understand its meaning?\n2. Find out which areas of the Europe raster are most similar to the study area (this may take a minute or so). Try different window sizes (e.g. 200 or 500).\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}