{
  "hash": "dfce73519934997283b64ee3a22a9134",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial patterns of non-categorical rasters\"\nsubtitle: \"Retrieve patterns from continuous data\"\nauthor: \"Chris Reudenbach\"\nexecute:\n  eval: false\n  echo: true\ntitle-slide-attributes:\n  data-background-image: slide1/preview-image-mof.png\n  #data-background-size: contain\n  data-background-opacity: \"0.5\"\nformat:\n  revealjs:\n    theme: [../_extensions/metropolis-theme/metropolis.scss]\n    toc: false\n    toc-depth: 2\n    chalkboard: true\n    slide-number: true\n    footer: <gisma 2024>\n    menu: true\nlightbox: true\nspotlight:\n      useAsPointer: true\n      size: 5\n---\n\n\n## Climate data - best practicse\n\nFirst we need to setup our environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"geodata\")\ndevtools::install_github(\"Nowosad/spquery\")\ndevtools::install_github(\"Nowosad/patternogram\")\ndevtools::install_github(\"Nowosad/supercells\")\nlibrary(terra); library(sf);library(geodata);library(mapview);library(spquery);library(patternogram)\n```\n:::\n\n\nUsing the `geodata` package (helper package for `terra`) we can download in a very comfortable often used core data sets. In this case Worldclim and \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# German border on top level (nation)\nde = geodata::gadm(country = \"DEU\",level = 0,path = tempdir())\n# Worldclim historical climate data for Germany https://www.worldclim.org/data/index.html\nwc_tmin_de = worldclim_country(\"Germany\", var=\"tmin\", path=tempdir())\n# WCRP Coupled Model Intercomparison Project data https://www.wcrp-climate.org/wgcm-cmip\ncmip_tmin_2_5  = geodata::cmip6_world(\"CNRM-CM6-1\", \"585\", \"2061-2080\", var=\"tmin\", res=10, path=tempdir())\n# cropping and masking\nwc_tmin_de = crop(wc_tmin_de,de,mask=T)\ncmip_tmin_2_5_de = crop(cmip_tmin_2_5 , de,mask=T)\n# set plotting layout\nnf <- layout( matrix(c(1,2), ncol=2) )\n\nplot(cmip_tmin_2_5_de)\nplot(wc_tmin_de)\n```\n:::\n\n\n::: {.callout-important appearance=\"minimal\"}\nNote: Please check the websites for the meaning of the data\n:::\n\n---\n\n## Minimum temperature (°C)\n\n::::: columns\n::: {.column width=\"45%\"}\n![CMIP6 downscaled future climate projection for 2061-2080 [model: CNRM-ESM2-1; ssp: “585”]](../assets/cmip.png)\n:::\n\n::: {.column width=\"45%\"}\n![WorldClim version 2.1 climate data\nfor 1970-2000](../assets/wc.png)\n:::\n:::::\n\n\n------------------------------------------------------------------------\n\n\n## Identifying and comparing similar spatial patterns\n\nUsing the package `spquery` for finding similarities in  continous raster data (e.g., raster time-series)\n\n\n::: [.columns]\n\n::: {.column width=\"45%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# get Marburg and make it a spatial point\nmr = st_sf(st_sfc(st_point(c( 8.770833, 50.810001)),\n                  crs = \"EPSG:4326\"))\nvec = as.numeric(extract(wc_tmin_de, mr, ID = FALSE))\nvec\n# search for similarity in the data set\nsearch_tmin = spq_search(vec, cmip_tmin_2_5_de,\n                         dist_fun = \"euclidean\")\n\n# visualize\nplot(search_tmin,\n     plg = list( loc = \"topright\",title = \"Dissimilarity\"))\nplot(mr, add=TRUE, col='red', lwd=4)\n```\n:::\n\n\n![Comparison historical Marburg vs CMIP ](../assets/search.png){width=\"65%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# some cleaning\ncrop= crop( wc_tmin_de,cmip_tmin_2_5_de)\nres = resample(crop,cmip_tmin_2_5_de)\n\n# call comparison\ncompare_tmin = spq_compare(cmip_tmin_2_5_de, res,\n                           dist_fun = \"euclidean\")\n\n# visualize\nplot(compare_tmin,\n     plg = list( loc = \"topright\",title = \"Dissimilarity\"), \n     col =viridis(256))\nplot(mr, add=TRUE, col='red', lwd=4)\n```\n:::\n\n![Comparison Worldclim vs CMIP](../assets/comp.png){width=\"65%\"}\n\n:::\n:::\n\n\n---\n\n## patternogram\n\nDescribing the range of spatial autocorrelation\n\n- explore spatial autocorrelations of predictors in machine learning models\n- detect spatial autocorrelation in various data structures\n- compare the spatial autocorrelation of variables over time\n- investigate spatial autocorrelation of categorical spatial patterns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patternogram)\nlibrary(ggplot2)\npg1_100 = patternogram(wc_tmin_de, sample_size = 10)\npg2_100 = patternogram(cmip_tmin_2_5_de, sample_size = 10)\npg1_500 = patternogram(wc_tmin_de, sample_size = 100)\npg2_500 = patternogram(cmip_tmin_2_5_de, sample_size = 100)\npg1_1000 = patternogram(wc_tmin_de, sample_size = 1000)\npg2_1000 = patternogram(cmip_tmin_2_5_de, sample_size = 1000)\nggplot() + geom_point(data=pg1_100, aes(x=dist, y=dissimilarity), color='red4') +\n           geom_point(data=pg2_100, aes(x=dist, y=dissimilarity), color='red') +\n           geom_point(data=pg1_500, aes(x=dist, y=dissimilarity), color='blue') +\n           geom_point(data=pg2_500, aes(x=dist, y=dissimilarity), color='lightblue') +\n           geom_point(data=pg1_1000, aes(x=dist, y=dissimilarity), color='green') +\n           geom_point(data=pg2_1000, aes(x=dist, y=dissimilarity), color='darkgreen')            \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patternogram)\nlibrary(ggplot2)\npg1_100 = patternogram(wc_tmin_de, width = 100, sample_size = 10)\npg2_100 = patternogram(cmip_tmin_2_5_de, width = 100 ,sample_size = 10)\npg1_500 = patternogram(wc_tmin_de,  width = 100,sample_size = 10)\npg2_500 = patternogram(cmip_tmin_2_5_de,  width = 100,sample_size = 10)\npg1_1000 = patternogram(wc_tmin_de,  width = 100,sample_size = 10)\npg2_1000 = patternogram(cmip_tmin_2_5_de, width = 100,sample_size = 10)\nggplot() + geom_point(data=pg1_100, aes(x=dist, y=dissimilarity), color='red4') +\n           geom_point(data=pg2_100, aes(x=dist, y=dissimilarity), color='red') +\n           geom_point(data=pg1_500, aes(x=dist, y=dissimilarity), color='blue') +\n           geom_point(data=pg2_500, aes(x=dist, y=dissimilarity), color='lightblue') +\n           geom_point(data=pg1_1000, aes(x=dist, y=dissimilarity), color='green') +\n           geom_point(data=pg2_1000, aes(x=dist, y=dissimilarity), color='darkgreen')            \n```\n:::\n\n---\n\n::: {#fig-elephants layout-ncol=2}\n\n\n![k = 250, compactness = 4](../assets/pat1.png)\n\n![k = 50, compactness = 4](../assets/pat3.png)\n:::\n\n---\n\n\n## Slic /supercells\n\n**supercells**: an extension of SLIC (Simple Linear Iterative Clustering; Achanta et al. (2012), doi:10.1109/TPAMI.2012.120) that can be applied to non-imagery geospatial rasters that carry:\n\n- pattern information (co-occurrence matrices)\n- compositional information (histograms)\n- time-series information (ordered sequences)\n- other forms of information for which the use of Euclidean distance may not be justified\n- Segmentation/regionalization: partitioning space into smaller segments while minimizing internal inhomogeneity and maximizing external isolation\n\n\n\n\n::: {.callout-important appearance=\"minimal\"}\nSLIC/supercells are a way to improve the output and reduce the cost of segmentation\n:::\n\n\n\n---\n\n\n## Code examples\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(supercells)\n# Version 1\nmintemp_zones = supercells(cmip_tmin_2_5_de, k = 250, compactness = 4)\nplot(cmip_tmin_2_5_de[[1]]); plot(mintemp_zones, add = TRUE, col = NA)\n# Version 2\nmintemp_zones = supercells(cmip_tmin_2_5_de, k = 50, compactness = 4)\nplot(cmip_tmin_2_5_de[[1]]); plot(mintemp_zones, add = TRUE, col = NA)\n# Version 3\nmintemp_zones = supercells(cmip_tmin_2_5_de, k = 250, compactness = 1)\nplot(cmip_tmin_2_5_de[[1]]); plot(mintemp_zones, add = TRUE, col = NA)\n```\n:::\n\n\n\n::: {#fig-elephants layout-ncol=3}\n\n\n![k = 250, compactness = 4](../assets/su1.png)\n\n![k = 50, compactness = 4](../assets/su2.png)\n\n![k = 250, compactness = 1](../assets/su3.png)\n:::\n\n\n---\n\n### Code Examples - Helper functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(sf)\nlibrary(supercells)\nlibrary(rgeoda)\nlibrary(purrr)\nlibrary(tmap)\n\nrawdata=\"supercells-examples-main/raw-data/\"\n\n# create helper functions -------------------------------------------------\nget_dtw2d = function(x){\n  dist_mat = matrix(nrow = nrow(x), ncol = nrow(x))\n  for (i in seq_len(nrow(x))){\n    mat1 = matrix(unlist(x[i, ]), ncol = 2)\n    for (j in seq_len(nrow(x))){\n      mat2 = matrix(unlist(x[j, ]), ncol = 2)\n      dist_mat[i, j] = dtwclust::dtw_basic(mat1, mat2, norm = \"L2\", step.pattern = dtw::symmetric2)\n    }\n  }\n  stats::as.dist(dist_mat)\n}\ndtw_2d = function(x, y){\n  dtw2ddistance = dtwclust::dtw_basic(x = matrix(x, ncol = 2), y = matrix(y, ncol = 2),\n                                      norm = \"L2\", step.pattern = dtw::symmetric2,\n                                      error.check = FALSE)\n  return(dtw2ddistance)\n}\n\nregionalize_dtw_2d = function(k, superpixels, ...){\n  weight_df = st_drop_geometry(superpixels[, !colnames(superpixels) %in% c(\"supercells\", \"x\", \"y\")])\n  weight_dist = get_dtw2d(weight_df)\n  rook_w = rook_weights(superpixels)\n  skater_results = ?skater(k, rook_w, weight_df, random_seed = 1, cpu_threads = 1, scale_method = \"raw\",\n                          rdist = weight_dist)\n  superpixels$cluster = skater_results$Clusters\n  regions = aggregate(superpixels, by = list(superpixels$cluster), mean)\n  regions = st_cast(regions, \"POLYGON\")\n  regions$k = k\n  return(regions)\n}\n\n# normalize function\nscale_01 = function(r){\n \n  # get the min max values\n  minmax_r = range(values(r), na.rm=TRUE) \n  \n  # rescale \n  return( (r-minmax_r[1]) / (diff(minmax_r)))\n}\n```\n:::\n\n\n\n---\n\n## Code Examples - Regionalisation based on supercells\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create supercells based on the 2D time-series ---------------------------\nsp = supercells(c(ta, pr), step = 15, compactness = 0.01, dist_fun = dtw_2d)\nplot(sp)\n\n# create 3, 7, 11, and 15 regions based on the 2D time-series -------------\nsp_regions = ?map_dfr(c(3, 7, 11, 15), regionalize_dtw_2d, sp)\n\ntm_shape(sp_regions) +\n  tm_polygons() +\n  tm_facets(\"k\")\n```\n:::\n\n\n\n\n---\n\n## Exercises\n\nThe goal: to regionalize Germany's climates\n\n- Use Worldclim versus CMIP data\n- Use the upper helper functions and code for Great Britain\n\n\nExtended SLIC workflow uses the dynamic time warping (DTW) distance function rather than the Euclidean distance.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}